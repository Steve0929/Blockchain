<html>
<head>
<title>BlockChain</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
<link rel="stylesheet" type="text/css" href="piece.css">
<!-- <meta name="viewport" content="width=device-width"> -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="JQuery/jquery-3.1.1.js"> </script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
crossorigin="anonymous">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
crossorigin="anonymous">
</script>

<link rel="apple-touch-icon" sizes="57x57" href="pieceImg/favs/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="pieceImg/favs/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="pieceImg/favs/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="pieceImg/favs/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="pieceImg/favs/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="pieceImg/favs/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="pieceImg/favs/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="pieceImg/favs/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="pieceImg/favs/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="pieceImg/favs/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="pieceImg/favs/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="pieceImg/favs/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="pieceImg/favs/favicon-16x16.png">
<link rel="manifest" href="pieceImg/favs/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="pieceImg/favs/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>

</head>

<style>
#syc{
  width: 100%;
  top: 60%;
  height: 20%;

}
#text2{
  font-family: monospace;
  border-radius: 8px;
  background-color: grey;
  opacity: 1;
  padding: 5px;
  width: 100% !important;
  height: 12% !important;

}
#man{
border-color: rgb(255, 163, 158);
background-color: rgb(255, 241, 240);
color: rgb(245, 34, 45);
border-radius: 5px;
padding: 6px;
}


#datos{
  border: 0px !important;
  color: black !important;
  background-color: white !important;

}

.fa_custom {
color: #0099CC;
}

.hiddeIt{
visibility: hidden;
}

.loader {
width: 100% !important;
max-width: 30%;
}

.loadStatus{
padding: 15px;
left: 35%;
top: 2%;
position: absolute;
}

.plus{
  margin-left: 80%;
  top: -47px;
  position: relative;
  opacity: 0.7;
}

.plus:hover{
  opacity: 1;
}

.body{
  width: 100% !important;
  overflow-x: hidden !important;


}

.cubeIco{
  margin-left: 85%;
  top: 0px;
  position: relative;
}


.stage.addBlock
{
        -webkit-transform: scale(0.2);
        -ms-transform: scale(0.2);
        transform: scale(0.2);
        left: -500px;
        top: -200px;
}

.scaleDownForm
{
        -webkit-transform: scale(0.1, 0.15);
        -ms-transform: scale(0.1, 0.15);
        transform: scale(0.1, 0.15);
        margin-top: -30%;
        position:absolute !important;


}

.newBlockPos{
  top: -12%;
  position: absolute;
  max-height: 150px !important;
}

.scaleUpForm{
  -webkit-transform: scale(1);
  -ms-transform: scale(1);
  transform: scale(1);
  margin-left: 0%;
  position: absolute !important;


}

.mined{
border-color: rgb(183, 235, 143) !important;
background-color: rgb(246, 255, 237) !important;
color: rgb(82, 196, 26) !important;

}
.form {
  border-radius: 8px;
}
.form h1{
  color: white;
}

#blockContainer{
  margin-bottom: 0px;
  float: left !important;


}
#status{
/*border-color:  rgb(91, 72, 162);
background-color: rgb(116, 93, 197);
color: rgb(6, 43, 0); */
padding: 7px;
}
.img-circle{
-webkit-filter: brightness(100%);
}
.img-circle:hover{
-webkit-filter: brightness(90%);
}

#canvas{
width: 100% !important;
height: 20% !important;

}

.mobileEndHeight{
height: 20% !important;
}

.layerMob{
  top: 60% !important;
}

.textMobile2{
background-color: white !important;
background: white !important;
}


.scaleDownFormMobile
{
        -webkit-transform: scale(0.2 ,0.15);
        -ms-transform: scale(0.2 ,0.15);
        transform: scale(0.2 ,0.15);
        margin-top: 40% !important;
        top: 90%;
        position:absolute !important;
}


/*MOBILE**************************************************/
@media only screen and (max-device-width: 480px) {
.img-circle{
    width: 5%;
    height: 5%;
  }

.loader{
  position: relative !important;
  margin: 0px !important;
  max-width: 30%;
  left: 40% !important;

}

#syc{
  width: 100%;
  top: 40% ;
}

#canvas{
width: 100% !important;
height: 30% !important;
}

.layerMob{
  top: 50% !important;

}
.cubeIco{
  width: 65px;
  height: 50px;
  margin-left: 75%;
  top: -20% !important;


}

.newBlockPos{
  margin-top: -100%;
  max-height: 250px !important;
  position: relative !important;
}

.textMobile2{

top: 70% !important;
position: absolute !important;
width: 100%;
max-height: 100px;
padding: 3px !important;

}


#text2{
  font-family: monospace;
  border-radius: 8px;
  opacity: 0.8;

}

#man{
max-height: 290px !important;
}


}
</style>

<body>

<div id="canvas" class="mobileEndHeight">
<!--  <div id="blockContainer" class="stage containers z-depth-3"> -->
 <!-- </div> -->
</div>

<div id="loader" class="loader">
<div class="square" ></div>
<div class="square"></div>
<div class="square last"></div>
<div class="square clear"></div>
<div class="square"></div>
<div class="square last"></div>
<div class="square clear"></div>
<div class="square "></div>
<div class="square last"></div>
</div>
<br>

<div id="syc" class="layer card card-body ">
  <h5 id="sycp">Syncing with the latest chain...</h5>
  <img  id="cubeic"  onclick="toggleForm()" class="cubeIco" src="pieceImg/addc.png" width="65px" height="60px">
</div>

<!-- <div id="txtMobile" class=" auxM card card-body ">
</div> -->

<!--<div id="blockContainer" class="hiddeIt layer newBlockPos layer-1 light-blue darken-3 white-text"> -->

<div id="blockContainer" class="hiddeIt layer newBlockPos layer-1 light-blue darken-3 white-text">
  <div style= "padding-top: 70px !important"; id="chati2" class="container-fluid colores2" >
    <div class="form">
    <!--  <div class="modal-header">
       <button type="button" class="close btn btn-danger"  onclick="ecs()"  aria-hidden="true">Ã—</button>
           <button type="button" id="ecs"  onclick="ecs()" class="btn btn-danger">X</button>
     </div> -->


      <h1>Add a new block to the chain </h1>
      <br>
      <div  id="man2">
      <div id="status" class="card card-body ">
      <p>Status: </p>
      </div>
      <br>
    <div></div>
      <div id="man" class="card card-body ">
        <p>Hash</p>
      </div>
       <br>
      <input type="text" id="datos" placeholder="Add some data to this block">
      <br>
      <!-- <a href="#"><img src="pieceImg/min.png" class="img-circle"  onclick="startMining()" width="70" height="70" ></a> -->
      <button id="stM" type="button" onclick="startMining()"  class="btn btn-warning">Mine Block</button>
      <button id="chB" type="button" onclick="checkChain()" class="btn btn-warning">Check Blockchain</button>
      <!-- <button id="add" type="button"  onclick="addToEcosystem()" class="btn btn-warning">Add to the Blockchain</button> -->


    </div>
  </div>
  </div>
</div>


<script src="sha256.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="js/three.js"></script>
<script src="js/renderers/Projector.js"></script>
<script src="js/renderers/CanvasRenderer.js"></script>
<script src="js/controls/OrbitControls.js"></script>

<script>
class Block{
      constructor(index, timestamp, data, previousHash){
        this.index = index;
        this.timestamp = timestamp;
        this.previousHash = previousHash;
        this.data = data;
        this.hash = this.calculateHash();
        this.nonce = 0;
        this.Mine(4);
        this.ecoX= Math.random() * 1000 -500;
        this.ecoY= Math.random() * 1000 -500;
        this.ecoZ= Math.random() * 1000 -500;
        this.color = Math.random() * 0xffffff;
      }
      calculateHash(){
        return Sha256.hash(this.nonce + this.index + this.timestamp + this.previousHash + JSON.stringify(this.data)).toString();
      }
      Mine(difficulty){
        var arr = [];
        while(this.hash.substring(0, difficulty) !== Array(difficulty+1).join('0')){
            arr[this.nonce]= this.hash;
            //console.log("Minning block...");
            this.hash = this.calculateHash();
            //console.log(this.hash);
            this.nonce++;
        }
        console.log("Mined "+this.hash);
        var final = this.hash;
        var finalDat = this.data;
        var j = 0
        if(this.index !== 0){
           draw();
         }
      //render(final,arr,j);
        function draw() {
            document.getElementById("man").innerHTML = "<p>"+arr[j];+".</p>";
            j++;
            if (j < arr.length/90) {
                window.setTimeout(draw, 0);
                }
            else{
              document.getElementById("man").classList.add('mined');
              document.getElementById("man").innerHTML = "<p>"+final;+".</p>";
              document.getElementById("status").innerHTML = "<p>"+"Status: Block mined and successfully added to the chain"+".</p>";
              document.getElementById("datos").innerHTML = "<p>"+"xd"+"</p>";
              //document.getElementById("showDat").innerHTML = "<p>"+finalDat+"</p>";
                }
          }
      }
}
class BlockChain{
        constructor(){
          this.chain = [];
        }
        lastBlock(){
          return this.chain[this.chain.length -1];
        }
    /*    addBlock(newBlock){
          newBlock.previousHash = this.lastBlock().hash;
          newBlock.hash = newBlock.calculateHash();
          this.chain.push(newBlock);
        } */
        createBlock(data){
          var previousBlock = this.lastBlock();
          var previousBlockHash = this.lastBlock().hash;
          var newIndex = previousBlock.index + 1;
          var timestamp = Date.now();
          var newBlock = new Block (newIndex, timestamp, data, previousBlockHash);
          //newBlock.Mine(2);
          console.log("Adding block to the chain");
          this.chain.push(newBlock);
          console.log("Block added");
        }
        validChain(){
          for (var i = 1; i < this.chain.length; i++) {
              var  currentBlock = this.chain[i];
              var  previousBlock = this.chain[i-1];
            /*
              if(currentBlock.hash !== currentBlock.calculateHash()){
                  console.log("Calculated hash is invalid");
                  return false;
              }*/
              if(currentBlock.previousHash !== previousBlock.hash){
                return "The chain is not valid. A block hash is invalid.";

              }
              if(currentBlock.index !== (previousBlock.index)+1){
                return "The chain is not valid. A block index is invalid.";

              }
          }
          return "The chain is valid";
        }
}

var socket = io.connect();
var blockChain = new BlockChain();
var drawNewBlock = false;
var toggleAddForm = false;
var form =  document.getElementById('blockContainer');
//LOAD AND START*******
window.onload = function() {
if( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) {
    $( "#blockContainer" ).addClass('scaleDownFormMobile');
   }
else{$( "#blockContainer" ).addClass('scaleDownForm');
}
//INIT ENVIRO
setTimeout(startEnviro, 6000);
    };


$.get("/getLatestChainOnStart", function(data) {
      document.getElementById("sycp").innerHTML = "<p>"+"Syncing with the latest chain..."+"</p>";
      for (var i = 0; i < data.length; i++) {
           blockChain.chain[i] = data[i];
      }
      console.log("On start the latest chain is: "+JSON.stringify(blockChain));
    })

function startEnviro(){

  if(blockChain.chain.length ==0){
    document.getElementById("sycp").innerHTML = "<p>"+"The latest chain could not be synced"+".</p>";
    setTimeout(startEnviro, 3000);
  }
  else if(blockChain.chain.length >0){ //Synced can proceed to draw the chain
      document.getElementById("sycp").innerHTML = "<p>"+"Synced with the latest chain"+".</p>";
      init();
      animate();
      var loading = document.getElementById("loader");
      loading.remove();
      $( "#syc" ).addClass("layerMob");
    }
}



socket.on('Current_blockChain', function(data){
        document.getElementById("sycp").innerHTML = "<p>"+"Syncing with the latest chain..."+"</p>";
        blockChain.chain = []; //reset the chain
        for (var i = 0; i < data.length; i++) {
            blockChain.chain[i] = data[i];
            }
        console.log("The current most recent chain is: "+JSON.stringify(blockChain));
        if(blockChain.chain.length>0){
           document.getElementById("sycp").innerHTML = "<p>"+"Synced with the latest chain"+".</p>";
        }
        else{
           document.getElementById("sycp").innerHTML = "<p>"+"The latest chain could not be synced"+".</p>";
        }
    });

function startMining(){
  if( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) {
     alert("Mining will start now. Please be patient as this process is CPU intensive.");
    }
  document.getElementById("status").innerHTML = "<p>"+"Status: Mining block..."+".</p>";
  document.getElementById("man").classList.remove('mined');
  var datos = document.getElementById('datos').value;
  setTimeout( test(datos), 2000);
}

function test(data){
  blockChain.createBlock(data);
  var toSendBlock = blockChain.lastBlock();
  socket.emit('send_block', toSendBlock);
}

function checkChain(){
    document.getElementById("sycp").innerHTML = "<p> Status: "+ blockChain.validChain()+"</p>";
}


function addToEcosystem(){
    var hash = 0;
    var previousHash = 0;
    var data = 0;
    document.getElementById("blockContainer").classList.add('addBlock');
}



function toggleForm(){
  //$( "#blockContainer" ).slideToggle(1);
  if(!toggleAddForm){
     if( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) {
        document.getElementById('blockContainer').classList.remove('scaleDownFormMobile');
        document.getElementById('blockContainer').classList.add('scaleUpForm');
      }
    else{
         $( "#blockContainer" ).removeClass('scaleDownForm');
         $( "#blockContainer" ).addClass('scaleUpForm');
      }
     toggleAddForm = !toggleAddForm;
    }
  else if(toggleAddForm){
    if( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) {
        document.getElementById('blockContainer').classList.remove('scaleUpForm');
        document.getElementById('blockContainer').classList.add('scaleDownFormMobile');
       }
   else{
        $( "#blockContainer" ).removeClass('scaleUpForm');
        $( "#blockContainer" ).addClass('scaleDownForm');
       }
    toggleAddForm = !toggleAddForm;

  }
}

function ecs(){
  $( "#blockContainer" ).slideToggle(1);
}

//THREEJS BLOCKCHAIN ECOSYSTEM//
//****************************//
var WIDTH = window.innerWidth,
    HEIGHT = window.innerHeight,
    windowHalfX = WIDTH  / 2,
    windowHalfY = HEIGHT / 2;
var camera, cameraZ, scene, renderer,blocks, lines, materials = [], mouseX = 0, mouseY = 0, fov, aspectRatio, nearPlane, farPlane;
var fraction = 0;
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var projector = new THREE.Projector();


function init(){
fov = 75;
aspectRatio = WIDTH / HEIGHT;
nearPlane = 1;
farPlane = 2000; //3000
cameraZ = farPlane / 3;
var step = 0.5;
camera = new THREE.PerspectiveCamera(fov, aspectRatio, nearPlane, farPlane);

document.getElementById("blockContainer").classList.remove('hiddeIt');
//$( "#blockContainer" ).fadeOut(0);




camera.position.z = cameraZ;
scene = new THREE.Scene();
container = document.createElement('div');
document.body.appendChild(container);
document.body.style.margin = 0;
document.body.style.overflow = 'hidden';
geometry = new THREE.Geometry();
//Adding the blocks of the blockChain
var geometry = new THREE.Geometry();
var lineGeometry = new THREE.Geometry();
var positions = [];

var geometryC = new THREE.BoxGeometry( 50, 50, 50 );
var materialC = new THREE.MeshBasicMaterial( {color: 0x00ff00} );

//var cube = new THREE.Mesh( geometryC, materialC );
//scene.add( cube );

/*dots
for (i = 0; i <blockChain.chain.length; i++) {
  var dotGeometry = new THREE.Geometry();
  var x = blockChain.chain[i].ecoX;
  var y = blockChain.chain[i].ecoY;
  var z = blockChain.chain[i].ecoZ;
  dotGeometry.vertices.push(new THREE.Vector3( x, y, z));
  var dotMaterial = new THREE.PointsMaterial( { size: 20, sizeAttenuation: false } );
  var dot = new THREE.Points( dotGeometry, dotMaterial );
  dot.material.color.setHex(blockChain.chain[i].color);
  scene.add(dot);
  positions[i] = dot.position;
  //geometry.vertices.push( dot.position );
  geometry.vertices.push(new THREE.Vector3(x,y,z));
} */

for (i = 0; i <blockChain.chain.length; i++) {
  var dotGeometry = new THREE.BoxGeometry( 50, 50, 50 );
  var x = blockChain.chain[i].ecoX;
  var y = blockChain.chain[i].ecoY;
  var z = blockChain.chain[i].ecoZ;
  //dotGeometry.vertices.push(new THREE.Vector3( x, y, z));
  var dotMaterial = new THREE.PointsMaterial( { size: 20, sizeAttenuation: false } );
  // BASIC var materialC = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
  var materialC = new THREE.MeshBasicMaterial( {color: 0xffffff} );
  //var dot = new THREE.Points( dotGeometry, dotMaterial );
  var cube = new THREE.Mesh( geometryC, materialC );
  cube.material.color.setHex(blockChain.chain[i].color);
  cube.position.x = x;
  cube.position.y = y;
  cube.position.z = z;
  cube.userData.data = blockChain.chain[i].data;
  cube.userData.hash = blockChain.chain[i].hash;
  cube.userData.prevHash = blockChain.chain[i].previousHash;

  scene.add(cube);
  positions[i] = cube.position;
  //geometry.vertices.push( dot.position );
  geometry.vertices.push(new THREE.Vector3(x,y,z));
}



var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color:  0xffffff, opacity: 1 } ) );
scene.add( line );
/*
socket.on('draw_mined_block', function(data){
            console.log("draw mined");
            var geometry = new THREE.Geometry();
            var dotGeometry = new THREE.Geometry();
            var x = blockChain.chain[blockChain.chain.length-1].ecoX;
            var y = blockChain.chain[blockChain.chain.length-1].ecoY;
            var z = blockChain.chain[blockChain.chain.length-1].ecoZ;
            dotGeometry.vertices.push(new THREE.Vector3( x, y, z));
            var dotMaterial = new THREE.PointsMaterial( { size: 20, sizeAttenuation: false } );
            var dot = new THREE.Points( dotGeometry, dotMaterial );
            dot.material.color.setHex(blockChain.chain[blockChain.chain.length-1].color);
            scene.add(dot);
            geometry.vertices.push(new THREE.Vector3(blockChain.chain[blockChain.chain.length-2].ecoX,
                                    blockChain.chain[blockChain.chain.length-2].ecoY,
                                    blockChain.chain[blockChain.chain.length-2].ecoZ));
            geometry.vertices.push(new THREE.Vector3(x,y,z));


            var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff, opacity: 1 } ) );
            scene.add( line );
          });  */
var flag = false;



socket.on('draw_mined_block', function(data){
          scene.remove( linez );
          clearInterval(timer);

          var geometry = new THREE.Geometry();
          var dotGeometry = new THREE.BoxGeometry( 50, 50, 50 );
          var x = blockChain.chain[blockChain.chain.length-1].ecoX;
          var y = blockChain.chain[blockChain.chain.length-1].ecoY;
          var z = blockChain.chain[blockChain.chain.length-1].ecoZ;
          var dotMaterial = new THREE.PointsMaterial( { size: 20, sizeAttenuation: false } );
          var materialC = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
          var cube = new THREE.Mesh( geometryC, materialC );
          cube.position.x = x;
          cube.position.y = y;
          cube.position.z = z;
          cube.material.color.setHex(blockChain.chain[blockChain.chain.length-1].color);
          cube.userData.data = blockChain.chain[blockChain.chain.length-1].data;
          cube.userData.hash = blockChain.chain[blockChain.chain.length-1].hash;
          cube.userData.prevHash = blockChain.chain[blockChain.chain.length-1].previousHash;
          scene.add(cube);
          geometry.vertices.push(new THREE.Vector3(blockChain.chain[blockChain.chain.length-2].ecoX,
                                  blockChain.chain[blockChain.chain.length-2].ecoY,
                                  blockChain.chain[blockChain.chain.length-2].ecoZ));
          var xd = new THREE.Vector3(x,y,z);
          var linez = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x666666, opacity: 1 } ) );
          scene.add( linez );
          var timer = setInterval( addStep, 500 );
          var oldLength = xd.length();

          function addStep() {
          vertices = geometry.vertices;
          vertices.push(xd);
          //console.log((vertices));
          geometry = new THREE.Geometry();
          geometry.vertices = vertices;
          scene.remove( linez );
          linez = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff, opacity: 1 } ))
          scene.add( linez );
          console.log("execut");
          }

});

/*
socket.on('draw_mined_block', function(data){
          scene.remove( linez );
          clearInterval(timer);

          var geometry = new THREE.Geometry();
          var dotGeometry = new THREE.Geometry();
          var x = blockChain.chain[blockChain.chain.length-1].ecoX;
          var y = blockChain.chain[blockChain.chain.length-1].ecoY;
          var z = blockChain.chain[blockChain.chain.length-1].ecoZ;
          dotGeometry.vertices.push(new THREE.Vector3( x, y, z));
          var dotMaterial = new THREE.PointsMaterial( { size: 20, sizeAttenuation: false } );
          var dot = new THREE.Points( dotGeometry, dotMaterial );
          dot.material.color.setHex(blockChain.chain[blockChain.chain.length-1].color);
          scene.add(dot);
          geometry.vertices.push(new THREE.Vector3(blockChain.chain[blockChain.chain.length-2].ecoX,
                                  blockChain.chain[blockChain.chain.length-2].ecoY,
                                  blockChain.chain[blockChain.chain.length-2].ecoZ));
          var xd = new THREE.Vector3(x,y,z);
          //geometry.vertices.push(new THREE.Vector3(x,y,z));
          var linez = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x666666, opacity: 1 } ) );
          scene.add( linez );
          var timer = setInterval( addStep, 500 );
          var oldLength = xd.length();
          function addStep() {
          vertices = geometry.vertices;
          /*last = vertices[ vertices.length - 1 ];
          vertices.push(
          new THREE.Vector3(
          last.x + ( xd.x) * step,
          last.y + ( xd.y) * step,
          last.z + ( xd.z)* step )
          );*/
          //vertices.push(xd.setLength(xd.length()));
          //vertices.push(xd.divideScalar( 1 + ( 30 / oldLength ) ));
          //xd.setLength(100);
      /*    vertices.push(xd);
          //console.log((vertices));
          geometry = new THREE.Geometry();
          geometry.vertices = vertices;
          scene.remove( linez );
          linez = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff, opacity: 1 } ))
          scene.add( linez );
          console.log("execut");
          }

});  */



renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setClearColor (0x00000, 0 );
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(WIDTH, HEIGHT);
controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.addEventListener( 'change', render );

//container.appendChild(renderer.domElement);
document.getElementById('canvas').appendChild(renderer.domElement);
/* Event Listeners */
window.addEventListener('resize', onWindowResize, false);
document.addEventListener('mousemove', onDocumentMouseMove, false);
document.addEventListener('touchstart', onDocumentTouchStart, false);
document.addEventListener('touchmove', onDocumentTouchMove, false);
document.addEventListener( 'mousedown', onDocumentMouseDown, false );
}
function animate() {

        requestAnimationFrame(animate);
        controls.update();
        render();
        //stats.update();
    }
function render() {

  var time = Date.now() * 0.00005;
  //camera.position.x += (mouseX - camera.position.x) * 0.05;
  //camera.position.y += (-mouseY - camera.position.y) * 0.05;
  //camera.lookAt(scene.position);
  renderer.render(scene, camera);
    }


  function onDocumentMouseDown( e ) {
      if(document.getElementById("text2") !== null){
      var prevText = document.getElementById("text2");
      prevText.remove();
      }

      var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,     //x
                                        -( event.clientY / window.innerHeight ) * 2 + 1,  //y
                                        0.5 );
                                                                                //z
      raycaster.setFromCamera( mouse3D.clone(), camera );

      function createVector(x, y, z, camera, width, height) {
        var p = new THREE.Vector3(x, y, z);
        var vector = p.project(camera);
        vector.x = (vector.x + 1) / 2 * width;
        vector.y = -(vector.y - 1) / 2 * height;
        return vector;
    }

      scene.updateMatrixWorld();
      var intersects = raycaster.intersectObjects( scene.children);
      if(intersects.length >0){
        console.log(intersects[0].object.userData);
        //intersects[ 0].object.material.color.setHex( Math.random() * 0xffffff );
        xx= intersects[0].object.position.x;
        yy=intersects[ 0].object.position.y;
        zz=intersects[ 0].object.position.z;

        var text2 = document.createElement('div');
        text2.style.position = 'absolute';
        text2.id = 'text2';
        text2.style.width = 600;
        text2.style.height = 100;
        text2.style.backgroundColor = "";

        //text2.style.top =   (createVector(xx, yy , zz , camera, WIDTH, HEIGHT ).y); + 'px';
        //text2.style.left =   (createVector(xx, yy , zz , camera, WIDTH, HEIGHT ).x); + 'px';
        //document.body.appendChild(text2);

       if( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) {
         text2.innerHTML = "Data: "+intersects[0].object.userData.data+"<br>Hash: "+  intersects[0].object.userData.hash;
          document.body.appendChild(text2);
          document.getElementById("text2").classList.add('textMobile2');
          document.getElementById("text2").classList.add('mined');
        }


        else{
        text2.innerHTML = "Data: "+intersects[0].object.userData.data+"<br>Hash: "+
                          intersects[0].object.userData.hash+"<br>Previous Hash: "+
                          intersects[0].object.userData.prevHash;
        document.getElementById("sycp").appendChild(text2);
        document.getElementById("text2").classList.add('textMobile2');
        document.getElementById("text2").classList.add('mined');
      }
    }
  }




function onDocumentMouseMove(e) {
   mouseX = e.clientX - windowHalfX;
   mouseY = e.clientY - windowHalfY;
       }
/*	Mobile users?  I got your back homey	*/
function onDocumentTouchStart(e) {
   if (e.touches.length === 1) {
       //e.preventDefault();
       mouseX = e.touches[0].pageX - windowHalfX;
       mouseY = e.touches[0].pageY - windowHalfY;
               }
           }
function onDocumentTouchMove(e) {
   if (e.touches.length === 1) {
       //mobile scroll
       //e.preventDefault();
       mouseX = e.touches[0].pageX - windowHalfX;
       mouseY = e.touches[0].pageY - windowHalfY;
               }
           }
function onWindowResize() {
windowHalfX = window.innerWidth / 2;
windowHalfY = window.innerHeight / 2;
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
           }
</script>

</body>
</html>
